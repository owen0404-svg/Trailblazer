<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mindmap No Frameworks</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      margin: 0;
      height: 100vh;
      overflow: hidden;
      font-family: Arial, sans-serif;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: radial-gradient(circle at center, #0f0c29, #302b63, #24243e);
    }
    #bgParticles {
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none;
    }
    h1 {
      margin: 20px;
      font-size: 24px;
      text-shadow: 0 0 10px rgba(255,255,255,0.6);
      z-index: 2;
    }
    #searchBar {
      margin-bottom: 15px;
      z-index: 2;
    }
    input {
      padding: 8px;
      border-radius: 5px;
      border: none;
      width: 250px;
      margin-right: 8px;
    }
    button {
      padding: 8px 14px;
      border-radius: 5px;
      border: none;
      cursor: pointer;
      background: #03a9f4;
      color: white;
      font-weight: bold;
      box-shadow: 0 0 10px rgba(3,169,244,0.7);
      transition: 0.3s;
    }
    button:hover {
      background: #29b6f6;
      box-shadow: 0 0 20px rgba(3,169,244,1);
    }
    svg {
      flex: 1;
      width: 100%;
      height: 100%;
      cursor: grab;
      position: relative;
      z-index: 1;
      touch-action: none;
    }
    svg.dragging { cursor: grabbing; }
    .node circle { stroke: #fff; stroke-width: 2px; cursor: pointer; }
    .node text { fill: white; font-size: 12px; text-anchor: middle; pointer-events: none; }
    .link { stroke: #aaa; stroke-width: 2px; }
    .popup {
      position: absolute;
      background: rgba(15, 15, 35, 0.95);
      color: white;
      padding: 16px 20px;
      border-radius: 12px;
      font-size: 14px;
      max-width: 300px;
      box-shadow: 0 0 25px rgba(0,200,255,0.8);
      transform: scale(0.7);
      opacity: 0;
      transition: all 0.35s ease;
      z-index: 5;
      pointer-events: none;
    }
    .popup.show {
      transform: scale(1);
      opacity: 1;
      pointer-events: auto;
    }
    .popup h2 {
      margin: 0 0 8px;
      font-size: 18px;
      color: #03a9f4;
      text-shadow: 0 0 6px rgba(3,169,244,0.7);
    }
  </style>
</head>
<body>
  <canvas id="bgParticles"></canvas>

  <h1>TRAILBLAZER ROADMAP GENERATOR</h1>
  <div id="searchBar">
    <input type="text" id="query" placeholder="Search something..." />
    <button id="searchBtn">Search</button>
  </div>

  <svg id="mindmap" xmlns="http://www.w3.org/2000/svg">
    <g id="mapGroup"></g>
  </svg>

  <div id="popup" class="popup">
    <h2 id="popupTitle"></h2>
    <p id="popupDesc"></p>
    <button onclick="hidePopup()">Close</button>
  </div>

  <script>
    /* ===== Background particles ===== */
    (function () {
      const canvas = document.getElementById('bgParticles');
      const ctx = canvas.getContext('2d');
      let W, H, dpr, particles, linkDist, particleCount;
      function resize() {
        dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
        W = canvas.width = Math.floor(window.innerWidth * dpr);
        H = canvas.height = Math.floor((window.innerHeight) * dpr);
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        particleCount = Math.floor((W * H) / (14000 * dpr));
        particleCount = Math.max(50, Math.min(220, particleCount));
        linkDist = 120 * dpr;
        initParticles();
      }
      function initParticles() {
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const speed = 0.2 + Math.random() * 0.6;
          const angle = Math.random() * Math.PI * 2;
          particles.push({
            x: Math.random() * W,
            y: Math.random() * H,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            r: (1 + Math.random() * 2) * dpr,
            tw: Math.random() * 1000
          });
        }
      }
      function step(t) {
        ctx.clearRect(0, 0, W, H);
        const grad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H)/1.2);
        grad.addColorStop(0, 'rgba(255,255,255,0.02)');
        grad.addColorStop(1, 'rgba(0,0,0,0.08)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
        ctx.lineWidth = 0.6 * dpr;
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          p.x += p.vx; p.y += p.vy;
          if (p.x < -50) p.x = W + 50;
          if (p.x > W + 50) p.x = -50;
          if (p.y < -50) p.y = H + 50;
          if (p.y > H + 50) p.y = -50;
          for (let j = i + 1; j < particles.length; j++) {
            const q = particles[j];
            const dx = q.x - p.x, dy = q.y - p.y;
            const dist = Math.hypot(dx, dy);
            if (dist < linkDist) {
              const alpha = (1 - dist / linkDist) * 0.25;
              ctx.strokeStyle = 'rgba(180,220,255,' + alpha + ')';
              ctx.beginPath();
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(q.x, q.y);
              ctx.stroke();
            }
          }
        }
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          const twinkle = 0.6 + 0.4 * Math.sin((t * 0.001) + p.tw);
          ctx.beginPath();
          ctx.fillStyle = 'rgba(180,220,255,' + (0.35 + 0.45 * twinkle) + ')';
          ctx.arc(p.x, p.y, p.r * (0.9 + 0.3 * twinkle), 0, Math.PI * 2);
          ctx.fill();
        }
        requestAnimationFrame(step);
      }
      window.addEventListener('resize', resize);
      resize();
      requestAnimationFrame(step);
    })();

    /* ===== Mindmap ===== */
    const svg = document.getElementById("mindmap");
    const g = document.getElementById("mapGroup");
    const popup = document.getElementById("popup");
    const popupTitle = document.getElementById("popupTitle");
    const popupDesc = document.getElementById("popupDesc");

    const width = window.innerWidth;
    const height = window.innerHeight - 100;

    const colors = ["#6fa3ff","#03a9f4","#3f51b5","#9c27b0","#00d084","#1de9b6"];
    const descriptions = {};

    // OPTIONAL: set your OpenAI key at runtime, e.g.:
    // window.OPENAI_API_KEY = "sk-...";  // ⚠️ don't ship a real key to the browser

    async function fetchDescription(topic) {
  if (descriptions[topic]) return descriptions[topic];

  try {
    // Always try OpenAI first (your hardcoded key)
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": "Bearer"
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        messages: [
          { role: "system", content: "You are a helpful assistant that gives short, clear descriptions of concepts for a mindmap." },
          { role: "user", content: `Give me a concise 2–3 sentence description of: ${topic}` }
        ],
        max_tokens: 80,
        temperature: 0.7
      })
    });

    const data = await response.json();
    const desc = data.choices?.[0]?.message?.content?.trim() || "No description found.";
    descriptions[topic] = desc;
    return desc;

  } catch (err) {
    console.error("OpenAI failed:", err);
  }

  // If OpenAI fails, fallback to Wikipedia
  try {
    const title = encodeURIComponent(topic);
    const resp = await fetch(`https://en.wikipedia.org/api/rest_v1/page/summary/${title}`);
    if (!resp.ok) throw new Error("Wiki not found");
    const json = await resp.json();
    const desc = (json.extract || "No description found.").slice(0, 400);
    descriptions[topic] = desc;
    return desc;
  } catch (err) {
    console.warn("Wiki fallback failed:", err);
    const fallback = "No description available right now.";
    descriptions[topic] = fallback;
    return fallback;
  }
}


    let nodes = [], links = [], nodeElements = [], linkElements = [];

    function generateMindmap() {
      const query = document.getElementById("query").value || "Technology";
      g.innerHTML = "";
      nodes = [
        { id: query, group: 1 },
        { id: `${query} - History`, group: 2 },
        { id: `${query} - Applications`, group: 2 },
        { id: `${query} - Future`, group: 2 },
        { id: "AI", group: 3 },
        { id: "Blockchain", group: 3 },
        { id: "Quantum Computing", group: 3 },
        { id: "Healthcare", group: 4 },
        { id: "Finance", group: 4 },
        { id: "Education", group: 4 }
      ];
      links = [
        { source: query, target: `${query} - History` },
        { source: query, target: `${query} - Applications` },
        { source: query, target: `${query} - Future` },
        { source: `${query} - Applications`, target: "AI" },
        { source: `${query} - Applications`, target: "Blockchain" },
        { source: `${query} - Applications`, target: "Quantum Computing" },
        { source: "AI", target: "Healthcare" },
        { source: "AI", target: "Education" },
        { source: "Blockchain", target: "Finance" }
      ];

      nodes.forEach((n) => {
        n.x = width / 2 + (Math.random() - 0.5) * 300;
        n.y = height / 2 + (Math.random() - 0.5) * 300;
        n.vx = 0;
        n.vy = 0;
      });

      linkElements = links.map(l => {
        const line = document.createElementNS("http://www.w3.org/2000/svg","line");
        line.setAttribute("class","link");
        g.appendChild(line);
        return { line, source: l.source, target: l.target };
      });

      nodeElements = nodes.map(node => {
        const ng = document.createElementNS("http://www.w3.org/2000/svg","g");
        ng.setAttribute("class","node");

        const circle = document.createElementNS("http://www.w3.org/2000/svg","circle");
        circle.setAttribute("r", 20);
        circle.setAttribute("fill", colors[node.group % colors.length]);

        circle.addEventListener("click", async (e) => {
          showPopup(node, e.pageX, e.pageY);
          circle.setAttribute("r", 30);
          setTimeout(() => circle.setAttribute("r", 20), 200);
        });

        const text = document.createElementNS("http://www.w3.org/2000/svg","text");
        text.setAttribute("dy", -30);
        text.textContent = node.id;

        ng.appendChild(circle);
        ng.appendChild(text);
        g.appendChild(ng);

        // Drag logic per node
        let dragging = false;
        circle.addEventListener("mousedown", (e) => {
          e.stopPropagation();
          dragging = true;
          node.fixed = true;
          lastDragX = e.clientX;
          lastDragY = e.clientY;
          currentDragNode = node;
        });

        svg.addEventListener("mousemove", (e) => {
          if (dragging && currentDragNode === node) {
            const dx = (e.clientX - lastDragX);
            const dy = (e.clientY - lastDragY);
            node.x += dx / scale; // respect zoom
            node.y += dy / scale;
            node.vx = node.vy = 0;
            lastDragX = e.clientX;
            lastDragY = e.clientY;
          }
        });

        const endDrag = () => {
          if (dragging && currentDragNode === node) {
            dragging = false;
            node.fixed = false;
            currentDragNode = null;
          }
        };
        svg.addEventListener("mouseup", endDrag);
        svg.addEventListener("mouseleave", endDrag);

        return { node, group: ng };
      });

      requestAnimationFrame(tick);
    }

    // Physics
    function tick() {
      const centerX = width / 2, centerY = height / 2;

      nodes.forEach(n => {
        if (!n.fixed) {
          const dx = centerX - n.x;
          const dy = centerY - n.y;
          n.vx += dx * 0.00015;
          n.vy += dy * 0.00015;
        }
      });

      links.forEach(l => {
        const s = nodes.find(n => n.id === l.source);
        const t = nodes.find(n => n.id === l.target);
        const dx = t.x - s.x, dy = t.y - s.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const desired = 150, k = 0.008;
        const diff = (dist - desired) * k;
        const nx = dx / dist, ny = dy / dist;
        if (!s.fixed) { s.vx += nx * diff; s.vy += ny * diff; }
        if (!t.fixed) { t.vx -= nx * diff; t.vy -= ny * diff; }
      });

      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const a = nodes[i], b = nodes[j];
          const dx = b.x - a.x, dy = b.y - a.y;
          const distSq = dx * dx + dy * dy;
          if (distSq > 0 && distSq < 12000) {
            const force = 50 / distSq;
            if (!a.fixed) { a.vx -= dx * force; a.vy -= dy * force; }
            if (!b.fixed) { b.vx += dx * force; b.vy += dy * force; }
          }
        }
      }

      nodes.forEach(n => {
        if (!n.fixed) {
          n.vx *= 0.55; n.vy *= 0.55;
          if (Math.abs(n.vx) < 0.005) n.vx = 0;
          if (Math.abs(n.vy) < 0.005) n.vy = 0;
          n.x += n.vx; n.y += n.vy;
        }
      });

      linkElements.forEach(le => {
        const s = nodes.find(n => n.id === le.source);
        const t = nodes.find(n => n.id === le.target);
        le.line.setAttribute("x1", s.x);
        le.line.setAttribute("y1", s.y);
        le.line.setAttribute("x2", t.x);
        le.line.setAttribute("y2", t.y);
      });

      nodeElements.forEach(ne => {
        ne.group.setAttribute("transform", `translate(${ne.node.x},${ne.node.y})`);
      });

      requestAnimationFrame(tick);
    }

    // Popup
    async function showPopup(node, x, y) {
      popupTitle.textContent = node.id;
      popupDesc.textContent = "Loading description...";
      popup.style.left = (x + 15) + "px";
      popup.style.top = (y - 20) + "px";
      popup.classList.add("show");

      const desc = await fetchDescription(node.id);
      popupDesc.textContent = desc;

      clearTimeout(popup._timeout);
      popup._timeout = setTimeout(() => hidePopup(), 6000);
    }
    function hidePopup(){ popup.classList.remove("show"); }

    // Zoom + Pan
    let scale = 1, translateX = 0, translateY = 0;
    let isDragging = false, lastX = 0, lastY = 0;
    let lastDragX = 0, lastDragY = 0;
    let currentDragNode = null;

    function updateTransform(){
      g.setAttribute("transform", `translate(${translateX},${translateY}) scale(${scale})`);
    }

    svg.addEventListener("wheel",(e)=>{
      e.preventDefault();
      const zoomFactor = 0.1;
      const pt = svg.createSVGPoint();
      pt.x = e.clientX; pt.y = e.clientY;
      const ctm = svg.getScreenCTM();
      if (!ctm) return;
      const cursor = pt.matrixTransform(ctm.inverse());

      const oldScale = scale;
      if (e.deltaY < 0) scale *= (1 + zoomFactor);
      else scale *= (1 - zoomFactor);
      scale = Math.max(0.3, Math.min(2, scale));

      translateX -= (cursor.x * (scale - oldScale));
      translateY -= (cursor.y * (scale - oldScale));
      updateTransform();
    }, { passive: false });

    svg.addEventListener("mousedown",(e)=>{
      if (currentDragNode) return;
      isDragging = true;
      lastX = e.clientX; lastY = e.clientY;
      svg.classList.add("dragging");
    });
    svg.addEventListener("mousemove",(e)=>{
      if (!isDragging) return;
      translateX += (e.clientX - lastX);
      translateY += (e.clientY - lastY);
      lastX = e.clientX; lastY = e.clientY;
      updateTransform();
    });
    const endPan = () => { isDragging = false; svg.classList.remove("dragging"); };
    svg.addEventListener("mouseup", endPan);
    svg.addEventListener("mouseleave", endPan);

    document.getElementById("searchBtn").addEventListener("click", generateMindmap);
    document.getElementById("query").addEventListener("keydown", (e)=>{ if(e.key==="Enter") generateMindmap(); });

    generateMindmap();
  </script>
</body>
</html>
